<!DOCTYPE html>
<html lang="pt-br">
    <head>
        <title>Algoritmo de Programação Dinâmica para o Problema da Quebra em Palavras</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lora:ital,wght@0,400;0,700;1,400;1,700&family=Open+Sans+Condensed:ital,wght@0,300;1,300&family=Open+Sans:ital,wght@0,300;0,400;0,700;0,800;1,300;1,400;1,700;1,800&family=Oxygen+Mono&family=Josefin+Sans:ital,wght@0,200;0,600;1,200;1,600&display=swap">
        <link rel="stylesheet" href="assets/css/reset.css">
        <link rel="stylesheet" href="assets/css/highlight.css">
        <link rel="stylesheet" href="assets/css/style.css">
        <link rel="stylesheet" href="assets/css/color.css">
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
        <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        <script async src="https://static.codepen.io/assets/embed/ei.js"></script>
        <script src="assets/js/highlight.js"></script>
        <script src="assets/js/script.js"></script>
    </head>
    <body>
        <div class="container">
            <header>
                <a href="">abrir tudo</a>
                <a href="">fechar tudo</a>
            </header>
            <main>

<p>Handout criado por Pedro Andrade, Willian Kenzo e Thiago Kawahara</p>
<h1>Algoritmo de Programação Dinâmica para o Problema da Quebra em Palavras</h1>
<h2>Problema</h2>
<p><strong>Qual a o problema?</strong></p>
<p>O problema da quebra em palavras consiste em dado um conjunto de palavras sem espaço, descobrir se esse mesmo conjunto de palavras pode ser separado por espaços ou não.</p>
<p><strong>Onde se encontra?</strong></p>
<p>Esse problema se encontra em grandes mecanismos de busca como o Google, Bing, Amazon e em entrevistas de emprego para as grandes empresas de tecnologia, como o Google.</p>
<p><strong>Qual a importância de solucionar esse problema?</strong></p>
<blockquote class="question">
<p>Exercício 1</p>
<p>Entre no site da Amazon e busque por “tvplasma”.
Depois entre no site das Americanas e faça a mesma busca.
Há diferença entre as respostas?</p>
<details class="answer">
<summary>Gabarito</summary>
<p>No site da Amazon é devolvido os resultados para “tv plasma”, já no site das Americanas não é encontrado nenhum resultado.</p>
</details>
</blockquote>
<p>Isso é um problema, visto que se você fosse comprar uma tv de plasma nas Americanas, e escrevesse “tvplasma” na ferramenta de busca, o site não te retornaria nenhum resultado. Dando a entender que as Americanas não vende tvs de plasma (o que não é verdade) e a empresa perderia a venda.</p>
<h2>Implementação</h2>
<p><strong>O que é dado?</strong></p>
<ul>
<li>Uma string (conjunto de palavras sem espaço).</li>
<li>Uma lista de palavras existentes (banco de dados).</li>
</ul>
<blockquote class="warning">
<p>Aviso</p>
<p>A lista de palavras existentes seria como um dicionário. Não o dicionário que a gente conhece da programação, mas aquele gigante livro cheio de palavras.</p>
</blockquote>
<p><strong>O que fazer?</strong></p>
<p>Fazer um algoritmo para descobrir se a string dada pode ser segmentada em espaços ou não.</p>
<p><strong>O que retornar?</strong></p>
<p>Um boolean:</p>
<ul>
<li>
<p>Se a string pode ser segmentada em espaços, retorna <span class="md-colorify md-colorify--green">True</span>.</p>
</li>
<li>
<p>Se a string não pode ser segmentada em espaços, retorna <span class="md-colorify md-colorify--red">False</span>.</p>
</li>
</ul>
<blockquote class="warning">
<p>Aviso</p>
<p>Por simplicidade iremos retornar apenas um boolean, mas facilmente poderiamos alterar o código para retornar as possíveis segmentações da string em espaço.</p>
</blockquote>
<h2>Prática</h2>
<p>Dado a seguinte lista de palavras:</p>
<pre><code class="language-py">[de, garrafa, agua, monitor, camisa, bordada]
</code></pre>
<p>E as seguintes strings:</p>
<pre><code class="language-py">"garrafadeagua"
"camisaxadrez"
"monitor"
"camisabordada"
</code></pre>
<blockquote class="question">
<p>Exercício 2</p>
<p>O que o algoritmo retornaria?</p>
<details class="answer">
<summary>Gabarito</summary>
<pre><code class="language-py">True 
False 
True
True
</code></pre>
<p>“garrafadeagua” retorna <span class="md-colorify md-colorify--green">True</span>, pois no banco de dados há “garrafa”, “de” e “agua”.</p>
<p>O mesmo para “monitor” e “camisabordada”.</p>
<p>“camisaxadrez” retorna <span class="md-colorify md-colorify--red">False</span>, pois no banco de dados não há a palavra “xadrez”, apesar de ter “camisa”.</p>
</details>
</blockquote>
<p>Agora que já sabemos as entradas e as saídas do algoritmo, vamos ver como o começo chega no fim.</p>
<p>Para isso iremos utilizar um algoritmo, cuja ideia seja pegar uma parte da string, e checar se cada uma delas é uma palavra ou não. Quando se acha uma palavra, o algoritmo faz a mesma estratégia para o resto da string original. Seguindo a seguinte ideia:</p>
<p>Pegando a string “garrafadeagua”, o algoritmo faria até encontrar a primeira palavra:</p>
<pre><code class="language-py">1 "g"
2 "ga"
3 "gar"
4 "garr"
5 "garra"
6 "garraf"
7 "garrafa"
</code></pre>
<p>Como dito, a cada iteração o algoritmo checa se a substring é uma palavra do dicionário ou não. No caso, na iteração 7 o algoritmo encontra “garrafa” e agora irá checar o resto da string (“deagua”) para ver se forma uma palavra, da seguinte forma:</p>
<pre><code class="language-py">1 "d"
2 "de"
</code></pre>
<blockquote class="question">
<p>Exercício 3</p>
<p>Agora que o algoritmo achou mais uma palavra, como ficaria as iterações do resto da string para achar outra palavra?</p>
<details class="answer">
<summary>Gabarito</summary>
<p>Depois de encontrar “de”, o algoritmo começaria a checar o resto da substring por outra palavra.</p>
<pre><code class="language-py">1 "a"
2 "ag"
3 "agu"
4 "agua"
</code></pre>
<p>Como chegamos no fim da string e o algoritmo achou a palavra “agua”. E como toda a string original pode ser dividida em “garrada”+“de”+“agua”, o algoritmo retorna <span class="md-colorify md-colorify--green">True</span>.</p>
</details>
</blockquote>
<blockquote class="question">
<p>Exercício 4</p>
<p>Qual método que a gente aprendeu em Desafios de Programação que segue a lógica de iteração feita acima?</p>
<details class="answer">
<summary>Gabarito</summary>
<p>O método de recursão!</p>
<p>O algoritmo de recursão permite checarmos a string por uma palavra e quando a encontramos, recursamos para o resto da string, e acaba quando chega no seu fim.</p>
</details>
</blockquote>
<p>Agora que já temos uma ideia do que o código irá fazer e qual algoritmo iremos usar, como o codificamos?
Para um melhor entendimento vamos representá-los na forma escrita e dividí-los em partes.</p>
<blockquote class="question">
<p>Exercício 5</p>
<p>Primeiramente, como fariamos um código (pode ser um pseudocódigo, ou qualquer coisa) que faria isso:</p>
<p>Lembrando que já recebemos a string (“garrafadeagua”).</p>
<pre><code class="language-py">1 "g"
2 "ga"
3 "gar"
4 "garr"
5 "garra"
6 "garraf"
7 "garrafa"
</code></pre>
<details class="answer">
<summary>Gabarito</summary>
<p>Nessa primeira interação utilizariamos um <strong>loop</strong> a qual irá pecorrer cada elemento da string sucessivamente, e um <strong>fatiamento</strong> para irmos aumentando a string analisada.</p>
<pre><code class="language-py">1 funcao word_break(string):
2    
3    para cada posição da letra da string:
4        Print(string[0:posição])
</code></pre>
</details>
</blockquote>
<p>Agora, para verificarmos se a substring é uma palavra, iremos adicionar na entrada da função um dicionário, que é um lista de palavras válidas, ou seja, um banco de dados. Além disso foi adicionado uma condição dentro do loop a qual só irá entrar caso a palavra exista dentro do banco de dados.</p>
<pre><code class="language-py">1 funcao word_break(string, dicionario):
2
3    para cada posição da letra da string:
4        caso string[0:posição] esteja no dicionário:
5            Print(string[0:posição])
</code></pre>
<blockquote class="question">
<p>Exercício 6</p>
<p>Agora a entrada da função word_break será “tvplasma” e o dicionário será [“tv”, “plasma”] o que seria printado na linha 5 em cada interação no loop?</p>
<details class="answer">
<summary>Gabarito</summary>
<pre><code class="language-py">1 "tv"
</code></pre>
<p>Provavelmente você estranhou que o algorítimo não ter printado a palavra “plasma” nas suas interações. Reveja o código acima e tente entender a causa disso.</p>
<p>Exatamente! Por enquanto o código não está cortando as palavras existentes e por isso nunca pega a palavra plasma, mas palavras como “tvp”, “tvpl”, “tvpla” e assim por diante, que não existem no banco de dados.</p>
</details>
</blockquote>
<blockquote class="question">
<p>Exercício 7</p>
<p>Agora que já conseguimos pegar partes da string original e identificar se essa parte é uma palavra válida, só resta checar o resto da string. Como fariamos isso?</p>
<details class="answer">
<summary>Gabarito</summary>
<p>Por recursão! E é com ele que iremos resolver o problema do exercício anterior, a quebra da string quando uma palavra já foi identificada no loop.</p>
<pre><code class="language-py">1 funcao word_break(string, dicionario):
2  
3
4    para cada posição da letra da string:
5        caso string[0:posição] esteja no dicionário:
6        
7            caso word_break(string[posição:], dicionario): # Verifica se o resto da string é segmentada de forma recursiva
9                devolve true
10    
11    devolve false
</code></pre>
<p>Adicionamos a chamada recursiva dentro da primeira condição a qual já foi implementada antes, porém iremos mandar o resto da string que não foi verificada se existe no banco de dados ou não, e dentro dessa condição iremos devolver True, ou seja, a string pode ser repartida e caso o loop acabe será devolvido False, dessa forma declarando que a string não pode ser repartida.</p>
</details>
</blockquote>
<blockquote class="question">
<p>Exercício 8</p>
<p>Faça uma breve simulação do código do exercício anterior com as entradas (“garrafadeagua”, [“garrafa”, “de”, “agua”]).</p>
<p>Qual o problema encontrado?</p>
<p>Dica: o que acontece depois de o algoritmo achar “agua”.</p>
<details class="answer">
<summary>Gabarito</summary>
<p>No final, quando o algoritmo acha a palavra “agua”, ainda é entrado na recursão da linha 7.</p>
<p>Como a gente está rodando um código recursivo, nós devemos por uma condição de parada se não ele rodará em um “loop infinito”. A condição seria quando o tamanho da string fosse 0, dessa forma devolvendo true.</p>
<pre><code class="language-py">1 funcao word_break(string, dicionario):
2    se string estiver vazia devolve true # Condição para retirar a recursão do "Loop infinito"
3
4    para cada posição da letra da string:
5        caso string[0:posição] esteja no dicionário:
6        
7            caso word_break(string[posição:], dicionario): # Verifica se o resto da string é segmentada de forma recursiva
9                devolve true
10    
11    devolve false
</code></pre>
</details>
</blockquote>
<blockquote class="question">
<p>Exercício 9</p>
<p>Agora que já temos praticamente a ideia e o código entendidos.</p>
<p>Com a string de entrada “tvplasma” e o dicionário ["tv, “plasma”]. Você consegue explicar como esse algorítmo verificar se a string realmente consegue ser repartida ou não?</p>
<details class="answer">
<summary>Gabarito</summary>
<p>Quando o código entrar na primeira condição, ou seja quando ele afirmar que “tv” é uma palavra que exista no banco de dados, o resto da string, ou seja, “plasma”, que vem logo após “tv”, será enviado para a recursão da função verificando que “plasma” também existe no banco de dados devolvendo true.</p>
</details>
</blockquote>
<blockquote class="question">
<p>Exercício 10</p>
<p>Imagine agora que as entradas das funções vão ser “garrafadeagua” e o dicionário seja [“garrafa”, “agua”] qual seria a saída? Ele faria alguma recursão?</p>
<details class="answer">
<summary>Gabarito</summary>
<pre><code class="language-py">1 False
</code></pre>
<p>Você poderia pensar que a string pode sim ser seguimentada em “garrafa de agua” e de fato você tem toda a razão, porém o banco de dados fornecido ao algoritmo não possui a palavra “de”, dessa forma ela não consegue seguimentá-la, entretanto a função acaba encontrando uma palavra: “garrafa”, fazendo uma recursão.</p>
</details>
</blockquote>
<p>Logo em seguida iremos por o código implementado no python para uma melhor compreensão.</p>
<pre><code class="language-py">1 def word_break(string, dicionario):
2    tamanho = len(string)
2    if tamanho == 0:
3        return True
4    
5    for i in range(1, tamanho+1):
6        if string[0: i] in dicionario and word_break(string[i: tamanho], dicionario):
7            return True
8
9    return False
</code></pre>
<blockquote class="question">
<p>Exercício 11</p>
<p>Você saberia dizer qual é a complexidade do algoritmo de recursão?</p>
<details class="answer">
<summary>Gabarito</summary>
<p>\(O(2^n)\)</p>
</details>
</blockquote>
<p><strong>Programação Dinâmica</strong></p>
<p><strong>O que é?</strong>
É um método de otimização de algoritmos que é uma espécie de um algoritmo de recursão com o apoio de uma tabela. Ou seja, a programação dinâmica, guarda os resultados dos subproblemas encontrados durante a recursão, para não ser preciso calcular novamente.</p>
<p><strong>Como isso se aplica ao nosso problema</strong>
O problema do algoritmo recursivo é a sua complexidade. Podemos suavizá-la implementando a programação dinâmica, já que, por salvar os resultados dos subproblemas, ele não precisa calcular novamente, o que acaba tornando-o mais rápido.</p>
<p>Agora para entendermos melhor a lógica da programação dinâmica, realizaremos ela passo a passo no código.</p>
<p>Para começar precisamos iniciar uma lista que possua o tamanho da string + 1 e todos os seus elementos iram apresentar o valor <span class="md-colorify md-colorify--red">False</span>, menos o seu primeiro valor.</p>
<p>Nós utilizamos essa lista para que o programa consiga identificar as palavras que já foram segmentadas antes (fará mais sentido mais a frente), o primeiro elemento dessa lista vai começar como <span class="md-colorify md-colorify--green">True</span>, pois uma string vazia sempre vai poder ser segmentada.</p>
<pre><code class="language-py">1 funcao word_break(string):
2    cria uma lista dp do tamanho da string + 1 preenchida com false menos o primeiro elemento
3    # O primeiro elemento de dp é true pois uma string vazia sempre pode ser segmentada.
</code></pre>
<p>O segundo passo é adicionar um loop e ele irá pecorrer cada letra da string</p>
<pre><code class="language-py">1 funcao word_break(string):
2    cria uma lista dp do tamanho da string + 1 preenchida com false menos o primeiro elemento
3    # O primeiro elemento de dp é true pois uma string vazia sempre pode ser segmentada.
4
5    para todo i no tamanho da string + 1:
6        Print(string[i])
</code></pre>
<p>Na terceira parte iremos adicionar uma nova entrada para a função, o dicionário, para servir como condição. Sendo assim, adicionaremos um loop interno que irá perorrer cada substring em relação ao i do loop externo checando se a substring formada
que comece em j e vai até i pertence ao dicionário ou não.</p>
<pre><code class="language-py">1 funcao word_break(string, dicionario):
2    cria uma lista dp do tamanho da string + 1 preenchida com false menos o primeiro elemento
3    # O primeiro elemento de dp é true pois uma string vazia sempre pode ser segmentada.
4
5    para todo i no tamanho da string + 1:
6        para todo j em i:
7            se string[j:i] pertece ao dicionario:
8                Print(string[j:i])
</code></pre>
<blockquote class="question">
<p>Exercício 12</p>
<p>Dado a seguinte lista de palavras e a string “tvplasma4kz” qual seria a saída do código?</p>
<pre><code class="language-py">tv,plasma, 4k, led, lcd, oled, brasil
</code></pre>
<details class="answer">
<summary>Gabarito</summary>
<pre><code class="language-py">1 "tv"
2 "plasma"
3 "4k"
</code></pre>
</details>
</blockquote>
<p>Como pode ser visto acima, o algorítimo já está conseguindo quebrar a string e verificar se existe ou não no dicionário, porém ele ainda não consegue identificar se a string realmente pode ser seguimentada ou não.</p>
<p>Para que ele consiga fazer essa proeza nós finalmente vamos utilizar a lista inicializada anteriormente. Primeiro vamos por uma condição adjunto com o outro, que só irá entrar nessa condição caso o valor da lista dp na posição j (do loop interno) for <span class="md-colorify md-colorify--green">True</span>, caso ele consiga ter as duas condições realizadas, vamos por verdadeira na lista a condição <span class="md-colorify md-colorify--green">True</span> na posição i e depois do loop iremos devolver o último elemento da lista.</p>
<p>Nós fazemos todas essas condições pois na lista dp ela irá marcar como <span class="md-colorify md-colorify--green">True</span> o início e o fim de uma palavra válida então caso a string consiga ser sedimentada ela sempre irá apresentar true no último elemento, pois será a marcação do fim da última string encontrada e caso não encontre tal palavra o último elemento será <span class="md-colorify md-colorify--red">False</span>.</p>
<pre><code class="language-py">1 funcao word_break(string, dicionario):
2    cria uma lista dp do tamanho da string + 1 preenchida com false menos o primeiro elemento
3    # O primeiro elemento de dp é true pois uma string vazia sempre pode ser segmentada.
4
5    para todo i no tamanho da string + 1:
6        para todo j em i:
7            se dp[j] e string[j:i] pertece ao dicionario:
8                dp[i] recebe true
9                quebra o loop interno
10    
11   devolve o último elemento da lista dp
</code></pre>
<blockquote class="question">
<p>Exercício 13</p>
<p>Agora para essa função com a entrada de “tvplasma” e o dicionário [“tv”, “plasma”] qual seria a saída ?</p>
<details class="answer">
<summary>Gabarito</summary>
<pre><code class="language-py">1 True
</code></pre>
</details>
</blockquote>
<p>Segue o código em python para que seja mais fácil a compreensão</p>
<pre><code class="language-py">def wordBreak(string, dictionary):
     
    # create a dp table to store results of subproblems
    # value of dp[i] will be true if string string can be segmented
    # into dictionary words from 0 to i.
    dp = [False for i in range(len(string) + 1)]
 
    # dp[0] is true because an empty string can always be segmented.
    dp[0] = True
 
    for i in range(len(string) + 1):
        for j in range(i):
            if dp[j] and string[j:i] in dictionary:
                dp[i] = True
                break
     
    return dp[len(string)]
</code></pre>
<p>A seguir temos uma breve animação do algoritmo para um maior entendimento:</p>
<div class="animation"><img class="frame" src="img/dinamo/dinamo01.png" alt="1"><img class="frame" src="img/dinamo/dinamo02.png" alt="2"><img class="frame" src="img/dinamo/dinamo03.png" alt="3"><img class="frame" src="img/dinamo/dinamo04.png" alt="4"><img class="frame" src="img/dinamo/dinamo05.png" alt="5"><img class="frame" src="img/dinamo/dinamo06.png" alt="6"><img class="frame" src="img/dinamo/dinamo07.png" alt="7"><img class="frame" src="img/dinamo/dinamo08.png" alt="8"><img class="frame" src="img/dinamo/dinamo09.png" alt="9"><img class="frame" src="img/dinamo/dinamo10.png" alt="10"><img class="frame" src="img/dinamo/dinamo11.png" alt="11"><img class="frame" src="img/dinamo/dinamo12.png" alt="12"><img class="frame" src="img/dinamo/dinamo13.png" alt="13"><img class="frame" src="img/dinamo/dinamo14.png" alt="14"><img class="frame" src="img/dinamo/dinamo15.png" alt="15"><img class="frame" src="img/dinamo/dinamo16.png" alt="16"><img class="frame" src="img/dinamo/dinamo17.png" alt="17"><img class="frame" src="img/dinamo/dinamo18.png" alt="18"><img class="frame" src="img/dinamo/dinamo19.png" alt="19"><img class="frame" src="img/dinamo/dinamo20.png" alt="20"><img class="frame" src="img/dinamo/dinamo21.png" alt="21"><img class="frame" src="img/dinamo/dinamo22.png" alt="22"><img class="frame" src="img/dinamo/dinamo23.png" alt="23"><img class="frame" src="img/dinamo/dinamo24.png" alt="24"><img class="frame" src="img/dinamo/dinamo25.png" alt="25"><img class="frame" src="img/dinamo/dinamo26.png" alt="26"><img class="frame" src="img/dinamo/dinamo27.png" alt="27"><img class="frame" src="img/dinamo/dinamo28.png" alt="28"><img class="frame" src="img/dinamo/dinamo29.png" alt="29"><img class="frame" src="img/dinamo/dinamo30.png" alt="30"><img class="frame" src="img/dinamo/dinamo9.png" alt="31"></div>
<blockquote class="question">
<p>Exercício 14</p>
<p>Você saberia dizer qual é a complexidade do algoritmo de programação dinâmica?</p>
<details class="answer">
<summary>Gabarito</summary>
<p>\(O(n^2)\)</p>
</details>
</blockquote>


            </main>
            <footer>
                <a href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank">
                    <img alt="CC BY-SA 4.0" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" title="Creative Commons Attribution-ShareAlike 4.0 International License"/>
                </a>
                © 2022 Marcelo Hashimoto
            </footer>
        </div>
    </body>
</html>
